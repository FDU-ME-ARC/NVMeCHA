`timescale 1ns / 1ps
/**
* NVMeCHA: NVMe Controller featuring Hardware Acceleration
* Copyright (C) 2021 State Key Laboratory of ASIC and System, Fudan University
* Contributed by Yunhui Qiu
*
* This program is free software: you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation, either version 3 of the License, or
* (at your option) any later version.
*
* This program is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU General Public License for more details.
*
* You should have received a copy of the GNU General Public License
* along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

//////////////////////////////////////////////////////////////////////////////////
// Company:  State Key Laboratory of ASIC and System, Fudan University
// Engineer: Yunhui Qiu
// 
// Create Date: 03/26/2020 11:05:26 PM
// Design Name: 
// Module Name: nvme_admin_data_submit
// Project Name: SSD Controller
// Target Devices: 
// Tool Versions: 
// Description: submit data from card to host for Admin Commands
// 
// Dependencies: 
// 
// Revision:
// Revision 0.01 - File Created
// Additional Comments:
// 
//////////////////////////////////////////////////////////////////////////////////
`include "nvme_param.vh"

module nvme_admin_data_submit #(
    parameter DATA_WIDTH = 256
)(
    input                         clk,
    input                         rst_n,
    
    // DMA descriptor info generated by PS
    input      [31 : 0]           ps_dsc_ctl, // [0] load, trace rising edge
    input      [31 : 0]           ps_dsc_len,
    input      [63 : 0]           ps_dsc_addr,
    
    output reg                    dma_trans_done,

    // BRAM Ports, Write Only
    input                         bp_clk,
    input                         bp_rst,
    input                         bp_en,
    input      [ 15:0]            bp_we,
    input      [ 12:0]            bp_addr,
    input      [127:0]            bp_wrdata,
    output     [127:0]            bp_rddata, 
    
    // C2H DMA descriptor
    input                         c2h_dsc_byp_ready,   
    output reg                    c2h_dsc_byp_load, 
    output reg [63 : 0]           c2h_dsc_byp_src_addr,   
    output reg [63 : 0]           c2h_dsc_byp_dst_addr,   
    output reg [27 : 0]           c2h_dsc_byp_len,   
    output reg [15 : 0]           c2h_dsc_byp_ctl, 
    
    // AXI ST interface to submit h2c data
    input                         axis_c2h_tready,
    output reg                    axis_c2h_tvalid,
    output reg [DATA_WIDTH-1:0]   axis_c2h_tdata,
    output reg [DATA_WIDTH/8-1:0] axis_c2h_tkeep,
    output reg                    axis_c2h_tlast 
);



localparam
    IDLE    = 3'b001,
    LOAD    = 3'b010,
    DATA    = 3'b100;

reg  [2:0] dsc_state;

wire ps_dsc_load_w;
reg  ps_dsc_load_r;

reg          bram_ren;
reg  [  6:0] bram_raddr;
wire [255:0] bram_rdata;

assign bp_rddata = 128'h0;

admin_data_bram admin_c2h_data_bram(            
  .clka  (clk          ),   // input wire clka              
  .ena   (bram_ren     ),   // input wire ena              
  .wea   (32'h0        ),   // input wire [31 : 0] wea     
  .addra (bram_raddr   ),   // input wire [6 : 0] addra    
  .dina  (256'h0       ),   // input wire [255 : 0] dina   
  .douta (bram_rdata   ),   // output wire [255 : 0] douta 
  .clkb  (clk          ),   // input wire clkb             
  .enb   (bp_en        ),   // input wire enb              
  .web   (bp_we        ),   // input wire [15 : 0] web     
  .addrb (bp_addr[11:4]),   // input wire [7 : 0] addrb    
  .dinb  (bp_wrdata    ),   // input wire [127 : 0] dinb   
  .doutb (             )    // output wire [127 : 0] doutb  
);


assign ps_dsc_load_w = ps_dsc_ctl[0];

always@(posedge clk or negedge rst_n)
if(~rst_n) begin
    ps_dsc_load_r <= 1'b0;
end else begin
    ps_dsc_load_r <= ps_dsc_load_w;
end  


always@(posedge clk or negedge rst_n)
if(~rst_n) begin
    dsc_state <= IDLE;
end else begin
    case(dsc_state)
        IDLE: begin
            if(ps_dsc_load_w & (~ps_dsc_load_r)) begin
                dsc_state <= LOAD;
            end else begin
                dsc_state <= IDLE;
            end
        end
        LOAD: begin
            if(c2h_dsc_byp_ready) begin
                dsc_state <= DATA;
            end else begin
                dsc_state <= LOAD;
            end
        end
        DATA: begin
            if(axis_c2h_tready & axis_c2h_tvalid & axis_c2h_tlast) begin
                dsc_state <= IDLE;
            end
        end
    endcase
end


// Submit DMA descriptor to transfer data
always@(posedge clk or negedge rst_n)
if(~rst_n) begin
    c2h_dsc_byp_load     <= 1'h0;
    c2h_dsc_byp_len      <= 28'h0;
    c2h_dsc_byp_src_addr <= 64'h0;
    c2h_dsc_byp_dst_addr <= 64'h0;
    c2h_dsc_byp_ctl      <= 16'h0;
end else if((dsc_state == LOAD) & c2h_dsc_byp_ready) begin
    c2h_dsc_byp_load     <= 1'h1;
    c2h_dsc_byp_len      <= ps_dsc_len[27:0];
    c2h_dsc_byp_src_addr <= 64'h0;
    c2h_dsc_byp_dst_addr <= ps_dsc_addr;
    c2h_dsc_byp_ctl      <= 16'h10;
end else begin
    c2h_dsc_byp_load     <= 1'h0;
//    c2h_dsc_byp_len      <= 28'h0;
//    c2h_dsc_byp_src_addr <= 64'h0;
//    c2h_dsc_byp_dst_addr <= 64'h0;
//    c2h_dsc_byp_ctl      <= 16'h0;
end 


always@(posedge clk or negedge rst_n)
if(~rst_n) begin
    dma_trans_done <= 1'h0;
end else if(axis_c2h_tready & axis_c2h_tvalid & axis_c2h_tlast) begin
    dma_trans_done <= 1'h1;
end else if(dsc_state == LOAD) begin
    dma_trans_done <= 1'h0;
end



localparam
        TRAN_IDLE    = 4'b0001,
        TRAN_START   = 4'b0010,
        TRAN_DATA    = 4'b0100,
        TRAN_FIN     = 4'b1000,
        DATA_BYTES   = DATA_WIDTH >> 3;
        
reg [ 3:0] axis_state; 
reg [15:0] remain_bytes;  
reg        flag;
reg        bram_ren_r;
reg        axis_c2h_tvalid_r;
reg        axis_c2h_tready_r;
reg [DATA_WIDTH-1:0] pre_data;


always @ (posedge clk or negedge rst_n)
begin
  if (!rst_n)
      bram_ren_r <= 1'h0;
  else
      bram_ren_r <= bram_ren;
end

////// preserve the former data before current bram_rdata /////
always @ (posedge clk or negedge rst_n)
begin
  if (!rst_n)
      axis_c2h_tvalid_r <= 1'h0;
  else
      axis_c2h_tvalid_r <= axis_c2h_tvalid;
end

always @ (posedge clk or negedge rst_n)
begin
  if (!rst_n)
      axis_c2h_tready_r <= 1'h0;
  else
      axis_c2h_tready_r <= axis_c2h_tready;
end

always @ (posedge clk or negedge rst_n)
begin
  if (!rst_n)
      pre_data <= 'h0;
  else if( (~axis_c2h_tvalid_r) | (axis_c2h_tready_r & axis_c2h_tvalid_r) )
      pre_data <= bram_rdata;  
end

//////


always@(posedge clk or negedge rst_n)
begin
  if(!rst_n) begin
      axis_state   <= TRAN_IDLE;
      remain_bytes <= 16'h0;
      bram_ren     <= 1'b0;
      axis_c2h_tdata    <= 'h0;
      axis_c2h_tkeep    <= 'h0;
      axis_c2h_tvalid   <= 1'b0;
      axis_c2h_tlast    <= 1'b0;
  end else begin
    case(axis_state)
        TRAN_IDLE:begin
            if(dsc_state == LOAD) begin 
                axis_state   <= TRAN_START;
        		remain_bytes <= ps_dsc_len[15:0];
        		bram_ren     <= 1'b1;
            end
          end
        TRAN_START: begin
            if(bram_ren_r & (remain_bytes > DATA_BYTES)) begin
                axis_state <= TRAN_DATA;
                axis_c2h_tvalid <= 1'b1;
                axis_c2h_tdata  <= flag ? pre_data : bram_rdata;
                axis_c2h_tkeep  <= 32'hffff_ffff;
                axis_c2h_tlast  <= 1'b0;
                remain_bytes <= remain_bytes - DATA_BYTES;
            end else if(bram_ren_r & (remain_bytes <= DATA_BYTES)) begin
                axis_state <= TRAN_FIN;
                axis_c2h_tvalid <= 1'b1;
                axis_c2h_tdata  <= flag ? pre_data : bram_rdata;
                axis_c2h_tkeep  <= 32'hffff_ffff >> (DATA_BYTES-remain_bytes);
                axis_c2h_tlast  <= 1'b1;
            end
          end
        TRAN_DATA:begin
            if(axis_c2h_tready & axis_c2h_tvalid & (remain_bytes > DATA_BYTES)) begin
                axis_c2h_tdata    <= flag ? pre_data : bram_rdata;
                remain_bytes <= remain_bytes - DATA_BYTES;
                axis_state   <= TRAN_DATA;
            end else if(axis_c2h_tready & axis_c2h_tvalid & (remain_bytes <= DATA_BYTES)) begin
                bram_ren  <= 1'b0;
                axis_c2h_tdata <= flag ? pre_data : bram_rdata;
                axis_c2h_tkeep <= 32'hffff_ffff >> (DATA_BYTES-remain_bytes);
                axis_c2h_tlast <= 1'b1;
                axis_state<= TRAN_FIN;
            end
          end
        TRAN_FIN:begin
            if(axis_c2h_tready & axis_c2h_tvalid) begin
                axis_c2h_tvalid <= 1'b0;
                axis_c2h_tkeep  <= 'h0;
                axis_c2h_tdata  <= 'h0;
                axis_c2h_tlast  <= 1'b0;
                axis_state <= TRAN_IDLE;
             end
           end
     endcase
   end
end


always@(posedge clk or negedge rst_n)
begin
  if(!rst_n)
      flag <= 1'h0;
  else if( (~axis_c2h_tready) & axis_c2h_tvalid )
      flag <= 1'h1;
  else
      flag <= 1'h0;
end


    
always@(posedge clk or negedge rst_n)
begin
  if(!rst_n)
      bram_raddr <= 7'h0;
  else if( (axis_state == TRAN_IDLE) )
      bram_raddr <= 7'h0;
  else if( (axis_state == TRAN_START) || (axis_c2h_tready & axis_c2h_tvalid & (axis_state == TRAN_DATA)) )
      bram_raddr <= bram_raddr + (DATA_BYTES >> 5); 
end    






endmodule
